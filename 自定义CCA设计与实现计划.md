# 自定义拥塞控制算法(CCA)设计与实现计划

## 一、任务目标

设计并实现一个新的拥塞控制算法,目标是**超越 TCP Reno 的性能**。

**评估指标**: 传输 1MB 文件所需的时间(吞吐量)

**测试环境**:
- RTT = 200ms
- 路由器缓冲区大小无限
- 当缓冲区深度超过 N 时,路由器会添加额外延迟 X ms
- 带宽: 10 Mbps
- 可能存在丢包

---

## 二、TCP Reno 性能分析

### 2.1 TCP Reno 的优点

1. **简单有效**: 实现简单,易于理解和维护
2. **公平性好**: AIMD 机制保证多个流之间的公平性
3. **稳定性**: 慢启动和拥塞避免机制使网络相对稳定

### 2.2 TCP Reno 的缺点与改进机会

| 问题 | 影响 | 改进方向 |
|-----|------|---------|
| **慢启动过于保守** | 在高带宽-时延产品(BDP)网络中,需要很长时间才能达到最优窗口 | 更激进的初始窗口增长 |
| **丢包=拥塞的假设** | 在无线/有损网络中,非拥塞丢包也会触发窗口减半 | 区分拥塞丢包和随机丢包 |
| **加性增长太慢** | 拥塞避免阶段每RTT只增加1 MSS,恢复速度慢 | 更快的窗口增长策略 |
| **乘性减少太激进** | 丢包时窗口减半可能过度反应 | 更温和的窗口减小 |
| **对RTT敏感** | 高RTT环境下吞吐量显著下降 | RTT自适应机制 |
| **缓冲区膨胀** | 持续填满路由器缓冲区,增加延迟 | 基于延迟的拥塞检测 |

---

## 三、改进算法设计方案

### 方案A: TCP BBR 简化版 (推荐)

**核心思想**: 基于带宽和RTT的拥塞控制,而非丢包

#### 算法特点

1. **探测带宽**: 周期性探测可用带宽
2. **最小RTT跟踪**: 监控最小RTT以检测缓冲区积累
3. **Pacing发送**: 按照估计的带宽速率发送数据包
4. **四个状态机**:
   - Startup: 快速增长到带宽
   - Drain: 排空过多的队列
   - ProbeBW: 周期性探测带宽
   - ProbeRTT: 周期性探测最小RTT

#### 性能优势

- 高吞吐量: 充分利用带宽
- 低延迟: 避免缓冲区膨胀
- 适应性强: 对网络变化响应快

#### 实现难度

⭐⭐⭐⭐ (较高,但效果最好)

---

### 方案B: TCP Cubic 简化版

**核心思想**: 使用三次函数调整拥塞窗口

#### 算法特点

1. **快速恢复**: 丢包后使用三次函数快速逼近之前的窗口大小
2. **凹凸函数**:
   - 凹区间: 快速增长(接近上次丢包窗口)
   - 凸区间: 探测更高带宽
3. **TCP友好**: 在低速网络中表现类似Reno

#### 窗口更新公式

```
W(t) = C(t - K)³ + W_max

其中:
- W_max: 上次丢包时的窗口大小
- K: 窗口从 W_max 减小到当前窗口所需的时间
- C: 常数因子
- t: 当前时间
```

#### 性能优势

- 高带宽利用率: 在高BDP网络中表现优异
- 快速收敛: 丢包后快速恢复
- 相对简单: 比BBR容易实现

#### 实现难度

⭐⭐⭐ (中等)

---

### 方案C: 增强型 Reno (最简单)

**核心思想**: 在Reno基础上进行参数优化和小改进

#### 改进点

1. **初始窗口优化**: IW从1 MSS增加到10 MSS
2. **快速恢复改进**:
   - 使用NewReno的部分确认机制
   - 避免多次窗口减半
3. **慢启动阈值调整**: 更智能的ssthresh设置
4. **选择性确认(SACK)**: 更高效的重传

#### 性能优势

- 实现简单: 修改量小
- 风险低: 基于成熟的Reno
- 兼容性好: 保持Reno的核心特性

#### 实现难度

⭐⭐ (简单)

---

## 四、推荐方案: 增强型 Reno + Cubic 混合

结合方案B和方案C的优点,实现一个**实用且高效**的算法:

### 4.1 算法设计

#### 状态机

```
[SLOW_START] ──丢包或达到ssthresh──> [CONGESTION_AVOIDANCE]
                                              │
                                        3个重复ACK
                                              │
                                              ▼
                                      [FAST_RECOVERY]
                                              │
                                          新ACK到达
                                              │
                                              ▼
                                   [CONGESTION_AVOIDANCE]
```

#### 关键参数

| 参数 | Reno默认值 | 新算法值 | 说明 |
|-----|-----------|---------|------|
| 初始窗口 | 1 MSS | 10 MSS | RFC 6928 |
| 慢启动增长 | 每ACK +1 MSS | 每ACK +1 MSS | 保持不变 |
| 拥塞避免增长 | 每RTT +1 MSS | Cubic函数 | 更快增长 |
| 丢包后减小 | × 0.5 | × 0.7 | 更温和 |
| ssthresh初始值 | 64 MSS | 128 MSS | 更高起点 |

#### 核心算法伪代码

```python
# 初始化
cwnd = 10 * MSS  # 初始窗口
ssthresh = 128 * MSS
W_max = 0  # 上次丢包时的窗口大小
last_loss_time = 0

# 收到ACK时
def on_ack_received(ack):
    if state == SLOW_START:
        cwnd += MSS  # 指数增长
        if cwnd >= ssthresh:
            state = CONGESTION_AVOIDANCE

    elif state == CONGESTION_AVOIDANCE:
        # Cubic增长
        t = current_time - last_loss_time
        K = cbrt((W_max - cwnd) / C)
        cubic_cwnd = C * (t - K)^3 + W_max

        # TCP友好性检查
        tcp_cwnd = cwnd + MSS / cwnd

        cwnd = max(cubic_cwnd, tcp_cwnd)

# 检测到丢包(3个重复ACK)
def on_loss_detected():
    W_max = cwnd
    ssthresh = cwnd * 0.7  # 更温和的减小
    cwnd = ssthresh + 3 * MSS
    state = FAST_RECOVERY
    last_loss_time = current_time

# 快速恢复期间收到重复ACK
def on_dupack_in_recovery():
    cwnd += MSS  # 膨胀窗口

# 快速恢复期间收到新ACK
def on_new_ack_in_recovery():
    cwnd = ssthresh
    state = CONGESTION_AVOIDANCE
```

### 4.2 实现细节

#### 需要修改的文件

| 文件 | 修改内容 |
|-----|---------|
| `inc/foggy_tcp.h` | 添加新状态和参数定义 |
| `inc/grading.h` | 修改初始参数 |
| `src/foggy_function.cc` | 实现新的窗口更新逻辑 |

#### 新增数据结构

```cpp
typedef struct {
  // 原有字段...

  // Cubic相关
  uint32_t W_max;              // 上次丢包时的窗口大小
  struct timespec last_loss_time;  // 上次丢包时间
  double cubic_C;              // Cubic常数

  // 统计信息
  uint32_t total_acks;         // 总ACK数
  uint32_t total_losses;       // 总丢包数
} window_t;
```

---

## 五、实验计划

### 5.1 基准测试

**目标**: 获取TCP Reno的基准性能

#### 测试场景

| 场景 | RTT | 带宽 | 丢包率 | 目的 |
|-----|-----|------|-------|------|
| 理想网络 | 40ms | 10Mbps | 0% | 最佳性能 |
| 中等延迟 | 200ms | 10Mbps | 0% | 高RTT影响 |
| 有损网络 | 40ms | 10Mbps | 0.1% | 丢包影响 |
| 综合测试 | 200ms | 10Mbps | 0.1% | 真实场景 |

#### 测试步骤

1. 使用tcconfig配置网络参数
2. 传输1MB文件,重复10次
3. 记录每次传输时间
4. 计算平均值、标准差、最小值、最大值

#### 数据记录格式

```csv
scenario,trial,rtt_ms,bandwidth,loss_rate,duration_ms,throughput_mbps
ideal,1,40,10Mbps,0.0,1234,6.79
ideal,2,40,10Mbps,0.0,1198,7.01
...
```

### 5.2 新算法实现

#### 步骤 1: 代码修改 (预计2-3小时)

1. 备份原始代码
2. 修改头文件,添加新数据结构
3. 实现Cubic窗口更新函数
4. 修改拥塞控制逻辑
5. 添加调试输出

#### 步骤 2: 单元测试 (预计1小时)

测试以下场景:
- 无丢包传输
- 慢启动阶段
- 拥塞避免阶段
- 快速重传和恢复

#### 步骤 3: 性能测试 (预计1-2小时)

使用与基准测试相同的场景,对比新算法和Reno的性能

### 5.3 数据分析

#### 对比指标

1. **吞吐量**: 主要评估指标
2. **传输时间**: 1MB文件传输时间
3. **稳定性**: 标准差
4. **公平性**: 与其他流共存时的表现

#### 可视化

生成以下图表:
1. 不同场景下的吞吐量对比柱状图
2. 传输时间箱线图
3. 窗口大小变化曲线(时间序列)
4. 性能提升百分比雷达图

---

## 六、报告撰写

### 6.1 算法提案部分

#### 结构

1. **背景与动机**
   - TCP Reno的局限性
   - 为什么需要新算法
   - 改进的目标

2. **算法设计**
   - 核心思想
   - 状态机图
   - 伪代码
   - 参数选择理由

3. **理论分析**
   - 为什么新算法能提高吞吐量
   - 数学推导(可选)
   - 与现有算法的对比

#### 示例内容框架

```markdown
### 算法提案

#### 1. 背景与动机

TCP Reno在高带宽-时延产品网络中存在以下问题:
- 慢启动阶段增长缓慢
- 拥塞避免的加性增长效率低
- 丢包时的乘性减少过于激进

本算法通过以下改进来解决这些问题...

#### 2. 算法设计

本算法命名为**Enhanced Cubic Reno (ECR)**,结合了...

**核心改进点**:
1. 初始窗口从1 MSS增加到10 MSS
2. 拥塞避免阶段使用Cubic函数
3. 丢包时窗口减小比例从0.5改为0.7

**状态转换**:
[插入状态机图]

**窗口更新算法**:
[插入伪代码]

#### 3. 理论分析

**吞吐量提升分析**:

在RTT=200ms, 带宽=10Mbps的环境下:
- BDP = 10Mbps × 200ms / 8 = 250KB ≈ 183 MSS

TCP Reno达到最优窗口需要的时间:
- 慢启动: log2(183) ≈ 7.5 RTT = 1.5秒
- 拥塞避免继续调整: 若干RTT

本算法达到最优窗口:
- 初始窗口10 MSS
- 慢启动: log2(183/10) ≈ 4.2 RTT = 0.84秒
- Cubic快速收敛

**预期性能提升**: 约30-50%
```

### 6.2 算法评估部分

#### 结构

1. **实验设置**
   - 测试环境
   - 测试参数
   - 测试方法

2. **实验结果**
   - 数据表格
   - 性能图表
   - 统计分析

3. **结果讨论**
   - 性能提升分析
   - 优势与不足
   - 适用场景

#### 示例内容框架

```markdown
### 算法评估

#### 1. 实验设置

**测试环境**:
- RTT: 200ms (使用tcconfig模拟)
- 带宽: 10 Mbps
- 丢包率: 0%, 0.1%, 0.5%
- 文件大小: 1 MB
- 重复次数: 每个场景10次

**对比基准**: TCP Reno标准实现

#### 2. 实验结果

##### 表1: 不同场景下的传输时间对比

| 场景 | Reno平均(ms) | ECR平均(ms) | 提升 | Reno标准差 | ECR标准差 |
|-----|-------------|------------|------|-----------|----------|
| 无丢包 | 1234 | 856 | 30.6% | 45 | 32 |
| 0.1%丢包 | 1567 | 1102 | 29.7% | 89 | 56 |
| 0.5%丢包 | 2145 | 1534 | 28.5% | 134 | 98 |

##### 图1: 传输时间对比

[插入柱状图]

##### 图2: 拥塞窗口变化曲线

[插入时间序列图,展示两种算法的窗口变化]

#### 3. 结果讨论

**主要发现**:
1. 在所有测试场景中,ECR都显著优于Reno
2. 性能提升在28.5%-30.6%之间
3. ECR的稳定性更好(标准差更小)

**性能提升原因**:
1. 更大的初始窗口减少了慢启动时间
2. Cubic函数加速了窗口增长
3. 更温和的窗口减小策略提高了恢复速度

**局限性**:
1. 在极高丢包率(>5%)下,性能优势减弱
2. 实现复杂度略高于Reno
3. 需要更多内存存储状态信息

**适用场景**:
- 高带宽-时延产品网络
- 中等丢包率(<2%)的环境
- 需要快速传输大文件的场景
```

---

## 七、开发时间表

| 阶段 | 任务 | 预计时间 |
|-----|------|---------|
| 1 | 算法设计和文档 | 2小时 |
| 2 | 代码实现 | 2-3小时 |
| 3 | 调试和测试 | 2小时 |
| 4 | 基准测试(Reno) | 1小时 |
| 5 | 新算法性能测试 | 1小时 |
| 6 | 数据分析和可视化 | 2小时 |
| 7 | 报告撰写 | 3小时 |
| **总计** | | **13-14小时** |

---

## 八、实现脚本准备

### 8.1 基准测试脚本

需要创建 `benchmark_reno.py`:
- 自动化测试多个场景
- 记录所有性能数据
- 生成CSV结果文件

### 8.2 性能对比脚本

需要创建 `compare_algorithms.py`:
- 加载Reno和新算法的数据
- 计算性能提升
- 生成对比图表

### 8.3 可视化脚本

需要创建 `visualize_results.py`:
- 生成各种图表
- 导出高质量图片
- 支持多种对比维度

---

## 九、成功标准

### 必须达成

✅ 新算法在至少一个场景下优于Reno
✅ 代码能够成功编译和运行
✅ 完成完整的性能对比实验
✅ 撰写详细的算法说明和评估报告

### 期望达成

⭐ 新算法在所有场景下都优于Reno
⭐ 性能提升超过20%
⭐ 实现过程中没有引入新bug
⭐ 报告内容充实,分析深入

---

## 十、风险与应对

### 风险1: 新算法性能不如Reno

**应对**:
- 准备多个备选方案
- 调整参数进行优化
- 如果确实不如,分析原因并在报告中说明

### 风险2: 实现过程中遇到Bug

**应对**:
- 充分测试每个组件
- 使用调试输出跟踪问题
- 保留原始Reno代码作为对照

### 风险3: 时间不够

**应对**:
- 优先实现方案C(增强型Reno)
- 简化测试场景
- 专注于核心功能

---

## 十一、参考资料

### 论文

1. **TCP Cubic**: "CUBIC: A New TCP-Friendly High-Speed TCP Variant" (2008)
2. **TCP BBR**: "BBR: Congestion-Based Congestion Control" (2016)
3. **RFC 6928**: "Increasing TCP's Initial Window" (2013)

### 实现参考

1. Linux内核TCP Cubic实现
2. Google BBR实现
3. TCP NewReno规范

---

**文档版本**: v1.0
**创建日期**: 2025-11-18
**最后更新**: 2025-11-18

---

## 附录A: 快速开始检查清单

开始实现前,确认:
- [ ] 已备份原始代码
- [ ] 理解Reno的实现逻辑
- [ ] 准备好测试环境
- [ ] 安装必要的Python库(numpy, matplotlib等)
- [ ] 创建新的git分支用于开发

## 附录B: 调试技巧

1. **添加详细日志**: 在关键位置输出窗口大小、状态变化
2. **使用Wireshark**: 抓包分析数据包交互
3. **对比输出**: 同时运行Reno和新算法,对比行为
4. **单步测试**: 先测试无丢包场景,再逐步增加复杂度

## 附录C: 常用命令

```bash
# 编译
cd /home/serennan/work/algo2/foggytcp2/foggytcp
make clean && make foggy

# 设置网络参数
sudo tcset eth0 --rate 10Mbps --delay 100ms --loss 0.1%

# 查看网络配置
sudo tcshow eth0

# 清除网络限制
sudo tcdel eth0 --all

# 运行测试
./server 127.0.0.1 15441 output.bin &
./client 127.0.0.1 15441 testfile.bin

# 查看传输时间
# Server会输出: Complete transmission in XXX ms
```
