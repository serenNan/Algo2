# Enhanced CCA 快速开始指南

## 项目结构

```
enhanced_cca/               # 改进算法专用文件夹
├── foggytcp/              # 源代码(从原始项目复制)
├── scripts/               # 测试脚本
├── results/               # 实验结果
├── testdata/              # 测试文件(软链接)
├── docs/                  # 文档
└── README.md
```

## 开发流程

### 阶段1: 准备工作 ✅

- [x] 创建独立项目文件夹
- [x] 复制原始代码
- [x] 创建目录结构
- [x] 链接测试文件

### 阶段2: 算法实现

#### 步骤1: 修改头文件

**文件**: `foggytcp/inc/foggy_tcp.h`

在 `window_t` 结构体中添加Cubic相关字段:

```cpp
typedef struct {
  // 原有字段
  uint32_t last_byte_sent;
  uint32_t last_ack_received;
  uint32_t dup_ack_count;
  uint32_t next_seq_expected;
  uint32_t ssthresh;
  uint32_t advertised_window;
  uint32_t congestion_window;
  reno_state_t reno_state;

  // 新增: Cubic相关字段
  uint32_t W_max;                    // 上次丢包时的窗口大小
  struct timespec last_loss_time;    // 上次丢包时间
  double cubic_C;                    // Cubic常数 (默认0.4)
} window_t;
```

#### 步骤2: 修改初始参数

**文件**: `foggytcp/inc/grading.h`

```cpp
// 修改前
#define WINDOW_INITIAL_WINDOW_SIZE MSS
#define WINDOW_INITIAL_SSTHRESH (MSS * 64)

// 修改后
#define WINDOW_INITIAL_WINDOW_SIZE (MSS * 10)  // RFC 6928
#define WINDOW_INITIAL_SSTHRESH (MSS * 128)
```

#### 步骤3: 初始化Cubic字段

**文件**: `foggytcp/src/foggy_tcp.cc`

在 `foggy_socket` 函数中添加初始化:

```cpp
// 找到初始化代码部分,添加:
sock->window.W_max = 0;
clock_gettime(CLOCK_MONOTONIC, &sock->window.last_loss_time);
sock->window.cubic_C = 0.4;  // Cubic标准常数
```

#### 步骤4: 实现Cubic窗口更新

**文件**: `foggytcp/src/foggy_function.cc`

添加Cubic辅助函数:

```cpp
#include <math.h>

// 计算三次方根
static double cbrt_custom(double x) {
  return pow(x, 1.0 / 3.0);
}

// Cubic窗口更新函数
static uint32_t cubic_update(foggy_socket_t *sock) {
  struct timespec now;
  clock_gettime(CLOCK_MONOTONIC, &now);

  // 计算时间差(秒)
  double t = (now.tv_sec - sock->window.last_loss_time.tv_sec) +
             (now.tv_nsec - sock->window.last_loss_time.tv_nsec) / 1e9;

  uint32_t W_max = sock->window.W_max;
  uint32_t cwnd = sock->window.congestion_window;
  double C = sock->window.cubic_C;

  // K = cbrt((W_max - cwnd) / C)
  double K = cbrt_custom((double)(W_max - cwnd) / C);

  // W_cubic = C * (t - K)^3 + W_max
  double cubic_cwnd = C * pow(t - K, 3) + W_max;

  // TCP友好性: W_tcp = cwnd + MSS/cwnd (每RTT增加1个MSS)
  double tcp_cwnd = cwnd + (double)MSS / cwnd;

  // 取较大值
  return (uint32_t)fmax(cubic_cwnd, tcp_cwnd);
}
```

#### 步骤5: 修改拥塞控制逻辑

**文件**: `foggytcp/src/foggy_function.cc`

修改 `handle_ack` 函数中的拥塞避免部分:

```cpp
void handle_ack(foggy_socket_t *sock, uint32_t ack) {
  if (ack == sock->window.last_ack_received) {
    sock->window.dup_ack_count++;
    debug_printf("Duplicate ACK count: %d\n", sock->window.dup_ack_count);

    if (sock->window.dup_ack_count == 3) {
      debug_printf("Fast retransmit triggered\n");

      // 修改: 更温和的窗口减小 (0.7 而不是 0.5)
      sock->window.W_max = sock->window.congestion_window;
      sock->window.ssthresh = MAX(sock->window.congestion_window * 0.7, MSS);
      sock->window.congestion_window = sock->window.ssthresh + 3 * MSS;
      sock->window.reno_state = RENO_FAST_RECOVERY;

      // 记录丢包时间
      clock_gettime(CLOCK_MONOTONIC, &sock->window.last_loss_time);

      // 快速重传逻辑...
      for (auto& slot : sock->send_window) {
        foggy_tcp_header_t *hdr = (foggy_tcp_header_t *)slot.msg;
        if (!has_been_acked(sock, get_seq(hdr))) {
          debug_printf("Retransmitting packet %d\n", get_seq(hdr));
          sendto(sock->socket, slot.msg, get_plen(hdr), 0,
                (struct sockaddr *)&(sock->conn), sizeof(sock->conn));
          break;
        }
      }
    } else if (sock->window.reno_state == RENO_FAST_RECOVERY && sock->window.dup_ack_count > 3) {
      sock->window.congestion_window += MSS;
    }
  } else if (after(ack, sock->window.last_ack_received)) {
    sock->window.dup_ack_count = 0;

    if (sock->window.reno_state == RENO_FAST_RECOVERY) {
      sock->window.congestion_window = sock->window.ssthresh;
      sock->window.reno_state = RENO_CONGESTION_AVOIDANCE;
      debug_printf("Exiting Fast Recovery, CWND: %d\n", sock->window.congestion_window);
    } else if (sock->window.reno_state == RENO_SLOW_START) {
      sock->window.congestion_window += MSS;
      debug_printf("Slow Start, CWND: %d\n", sock->window.congestion_window);

      if (sock->window.congestion_window >= sock->window.ssthresh) {
        sock->window.reno_state = RENO_CONGESTION_AVOIDANCE;
        debug_printf("Entering Congestion Avoidance\n");
      }
    } else if (sock->window.reno_state == RENO_CONGESTION_AVOIDANCE) {
      // 修改: 使用Cubic而不是线性增长
      sock->window.congestion_window = cubic_update(sock);
      debug_printf("Cubic Congestion Avoidance, CWND: %d\n", sock->window.congestion_window);
    }

    sock->window.last_ack_received = ack;
  }
}
```

### 阶段3: 编译和测试

#### 编译

```bash
cd /home/serennan/work/algo2/enhanced_cca/foggytcp
make clean
make foggy
```

#### 基础测试

**终端1:**
```bash
./server 127.0.0.1 15441 /tmp/output.bin
```

**终端2:**
```bash
./client 127.0.0.1 15441 ../testdata/test_1mb.bin
```

观察输出中的窗口大小变化,应该看到"Cubic Congestion Avoidance"的调试信息。

### 阶段4: 性能对比

创建性能对比脚本后运行:

```bash
cd /home/serennan/work/algo2/enhanced_cca/scripts
python3 benchmark.py
```

## 关键修改总结

| 组件 | 修改内容 | 文件 |
|-----|---------|------|
| 数据结构 | 添加W_max, last_loss_time, cubic_C | foggy_tcp.h |
| 初始参数 | IW: 1→10 MSS, ssthresh: 64→128 MSS | grading.h |
| 初始化 | 初始化Cubic字段 | foggy_tcp.cc |
| Cubic函数 | 实现cubic_update() | foggy_function.cc |
| 拥塞控制 | 窗口减小0.5→0.7, 使用Cubic增长 | foggy_function.cc |

## 预期改进

- **初始窗口增大**: 减少慢启动时间
- **Cubic增长**: 更快达到最优窗口
- **温和减小**: 提高丢包后的恢复速度

**预计性能提升**: 20-40%

## 调试技巧

1. **查看窗口变化**: 关注 `CWND:` 输出
2. **检查Cubic激活**: 应该看到 "Cubic Congestion Avoidance"
3. **对比Reno**: 同时运行原始和改进版本,对比窗口增长曲线

## 常见问题

### Q: 编译错误 - 找不到 `cbrt` 函数
**A**: 添加 `#include <math.h>` 并在Makefile中添加 `-lm` 链接数学库

### Q: 窗口大小没有按Cubic增长
**A**: 检查是否正确进入拥塞避免阶段,查看 `reno_state` 的值

### Q: 性能反而下降
**A**: 调整参数,特别是 `cubic_C` 的值 (默认0.4,可尝试0.3-0.5)

## 下一步

- [ ] 完成代码实现
- [ ] 编译成功
- [ ] 基础功能测试通过
- [ ] 创建性能对比脚本
- [ ] 运行基准测试
- [ ] 生成对比图表
- [ ] 撰写报告

## 参考资料

- 详细计划: `/home/serennan/work/algo2/自定义CCA设计与实现计划.md`
- 原始代码: `/home/serennan/work/algo2/foggytcp2/foggytcp/`
- TCP Cubic论文: [链接](https://dl.acm.org/doi/10.1145/1400097.1400105)
